# To add a new cell, type '# %%'
# To add a new markdown cell, type '# %% [markdown]'
# %% [markdown]
# # Gathered Notebook
# Gathered from ```c:\Users\Lenovo\Desktop\Git Repo\IBM - Behind The Code\desafio-2-2020\Assets\Notebooks\parte-1.ipynb```
#
# |   |   |
# |---|---|
# |&nbsp;&nbsp;&nbsp|This notebook was generated by the Gather Extension. It requires version 2020.7.94776 (or newer) of the Python Extension, please update [here](https://command:python.datascience.latestExtension). The intent is that it contains only the code and cells required to produce the same results as the cell originally selected for gathering. Please note that the Python analysis is quite conservative, so if it is unsure whether a line of code is necessary for execution, it will err on the side of including it.|
#
# **Are you satisfied with the code that was gathered?**
#
# [Yes](https://command:python.datascience.gatherquality?yes) [No](https://command:python.datascience.gatherquality?no)

# %%
import numpy as np
from sklearn.impute import SimpleImputer
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier


# %%
import pandas as pd
from input_path import path_input

df_data_1 = pd.read_csv(path_input)


# %%
import matplotlib.pyplot as plt
import seaborn as sns


# %%
fig, axes = plt.subplots(nrows=1, ncols=4, figsize=(28, 4))
sns.countplot(ax=axes[0], x='REPROVACOES_DE', data=df_data_1)
sns.countplot(ax=axes[1], x='REPROVACOES_EM', data=df_data_1)
sns.countplot(ax=axes[2], x='REPROVACOES_MF', data=df_data_1)
sns.countplot(ax=axes[3], x='REPROVACOES_GO', data=df_data_1)


# %%
fig, axes = plt.subplots(nrows=1, ncols=4, figsize=(28, 4))
sns.distplot(df_data_1['NOTA_DE'], ax=axes[0])
sns.distplot(df_data_1['NOTA_EM'], ax=axes[1])
sns.distplot(df_data_1['NOTA_MF'], ax=axes[2])


# %%
fig, axes = plt.subplots(nrows=1, ncols=4, figsize=(28, 4))
sns.countplot(ax=axes[0], x='INGLES', data=df_data_1)
sns.countplot(ax=axes[1], x='FALTAS', data=df_data_1)
sns.countplot(ax=axes[2], x='H_AULA_PRES', data=df_data_1)
sns.countplot(ax=axes[3], x='TAREFAS_ONLINE', data=df_data_1)


# %%
sns.countplot(x='PERFIL', data=df_data_1)


# %%
from sklearn.base import BaseEstimator, TransformerMixin
class DropColumns(BaseEstimator, TransformerMixin):
    def __init__(self, columns):
        self.columns = columns

    def fit(self, X, y=None):
        return self

    def transform(self, X):
        # Primeiro realizamos a cópia do dataframe 'X' de entrada
        data = X.copy()
        # Retornamos um novo dataframe sem as colunas indesejadas
        return data.drop(labels=self.columns, axis='columns')


# %%
rm_columns = DropColumns(
    columns=["NOME"]  # Essa transformação recebe como parâmetro uma lista com os nomes das colunas indesejadas
)


# %%
rm_columns.fit(X=df_data_1)
df_data_2 = pd.DataFrame.from_records(
    data=rm_columns.transform(
        X=df_data_1
    ),
)


# %%
si = SimpleImputer(
    missing_values=np.nan,  # os valores faltantes são do tipo ``np.nan`` (padrão Pandas)
    strategy='constant',  # a estratégia escolhida é a alteração do valor faltante por uma constante
    fill_value=0,  # a constante que será usada para preenchimento dos valores faltantes é um int64=0.
    verbose=0,
    copy=True
)


# %%
si.fit(X=df_data_2)
df_data_3 = pd.DataFrame.from_records(
    data=si.transform(
        X=df_data_2
    ),  # o resultado SimpleImputer.transform(<<pandas dataframe>>) é lista de listas
    columns=df_data_2.columns  # as colunas originais devem ser conservadas nessa transformação
)


# %%
features = [
    "MATRICULA", 'REPROVACOES_DE', 'REPROVACOES_EM', "REPROVACOES_MF", "REPROVACOES_GO",
    "NOTA_DE", "NOTA_EM", "NOTA_MF", "NOTA_GO",
    "INGLES", "H_AULA_PRES", "TAREFAS_ONLINE", "FALTAS",
]
target = ["PERFIL"]
X = df_data_3[features]
y = df_data_3[target]


# %%
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=337)


# %%
classifier_model = DecisionTreeClassifier()  # O modelo será criado com os parâmetros padrões da biblioteca


# %%
classifier_model.fit(
    X_train,
    y_train
)


# %%
y_pred = classifier_model.predict(X_test)


# %%
from sklearn.metrics import accuracy_score


# %%
import json
import os
method = 'IBM Solution Base'
classifier = 'Decision Tree'
description = '''Solucao feita a partir do video do behind the code
'''
file_name = 'Accuracy'
path = os.getcwd()
acc_value = 100*round(accuracy_score(y_test,y_pred),2)
dictionary ={
    "Accuracy": f"{acc_value}"
    ,"Method": f"{method}"
    ,"Classifier": f"{classifier}"
    ,"Description": f"{description}"
}
if not os.path.exists(f'{path}/{file_name}.json'):
    with open(f"{path}/{file_name}.json","w") as file:
        file.write("{}")
with open(f"{path}/{file_name}.json","r+") as file:
    data = json.load(file)
    data[f'{acc_value}'] = {}
    data[f'{acc_value}'].update(dictionary)
    file.seek(0)
    json.dump(data, file)


